/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type Metadata = V1_Metadata | V2_Metadata;
export type V1_SupergraphObject =
  | V1_HasuraSupergraphObject
  | OpenDdSupergraphObject;
export type V1_HasuraSupergraphObject = V1_CompatibilityConfig | AuthConfig;
export type CompatibilityDate = string;
/**
 * Definition of the authentication configuration used by the API server.
 */
export type AuthConfig = AuthConfigV1 | AuthConfigV2;
export type Role = string;
/**
 * The configuration for the authentication mode to use - webhook, JWT or NoAuth.
 */
export type AuthModeConfig =
  | {
      webhook: AuthHookConfig;
    }
  | {
      jwt: JWTConfig;
    }
  | {
      noAuth: NoAuthConfig;
    };
export type AuthHookMethod = 'Get' | 'Post';
/**
 * Config to describe how/where the engine should look for the claims within the decoded token.
 */
export type JWTClaimsConfig =
  | {
      locations: JWTClaimsMap;
    }
  | {
      namespace: JWTClaimsNamespace;
    };
export type JWTClaimsMappingEntry =
  | {
      literal: Role;
    }
  | {
      path: JWTClaimsMappingPathEntry;
    };
export type JWTClaimsMappingEntry1 =
  | {
      literal: Role[];
    }
  | {
      path: JWTClaimsMappingPathEntry1;
    };
export type JWTClaimsFormat = 'Json' | 'StringifiedJson';
/**
 * Source of the Authorization token
 */
export type JWTTokenLocation =
  | JWTBearerAuthorizationLocation
  | JWTCookieLocation
  | JWTHeaderLocation;
/**
 * JWT key configuration according to which the incoming JWT will be decoded.
 */
export type JWTKey =
  | {
      fixed: JWTKeyConfig;
    }
  | {
      jwkFromUrl: string;
    };
/**
 * The algorithm used to decode the JWT.
 */
export type JWTAlgorithm =
  | 'HS256'
  | 'HS384'
  | 'HS512'
  | 'ES256'
  | 'ES384'
  | 'RS256'
  | 'RS384'
  | 'RS512'
  | 'PS256'
  | 'PS384'
  | 'PS512'
  | 'EdDSA';
/**
 * Either a literal string or a reference to a Hasura secret
 */
export type EnvironmentValue =
  | {
      value: string;
    }
  | {
      valueFromEnv: string;
    };
/**
 * Value of a session variable
 */
export type SessionVariableValue = string;
export type OpenDdSupergraphObject = GraphqlConfig;
/**
 * GraphqlConfig object tells us two things:
 *
 * 1. How the Graphql schema should look like for the features (`where`, `order_by` etc) Hasura provides 2. What features should be enabled/disabled across the subgraphs
 */
export type GraphqlConfig = {
  kind: 'GraphqlConfig';
  version: 'v1';
  definition: GraphqlConfigV1;
};
/**
 * The name of a GraphQL type.
 */
export type GraphQlTypeName = string;
/**
 * The name of a GraphQL object field.
 */
export type GraphQlFieldName = string;
/**
 * Sort direction.
 */
export type OrderByDirection = 'Asc' | 'Desc';
export type V1_SubgraphObject = OpenDdSubgraphObject;
export type OpenDdSubgraphObject =
  | DataConnectorLink
  | GraphqlConfig1
  | ObjectType1
  | ScalarType1
  | ObjectBooleanExpressionType
  | BooleanExpressionType
  | DataConnectorScalarRepresentation
  | AggregateExpression
  | Model
  | Command
  | Relationship
  | TypePermissions
  | ModelPermissions
  | CommandPermissions
  | LifecyclePluginHook;
/**
 * Definition of a data connector, used to bring in sources of data and connect them to OpenDD models and commands.
 */
export type DataConnectorLink = {
  kind: 'DataConnectorLink';
  version: 'v1';
  definition: DataConnectorLinkV1;
};
/**
 * The name of a data connector.
 */
export type DataConnectorName = string;
/**
 * A URL to access a data connector. This can be a single URL or a pair of read and write URLs.
 */
export type DataConnectorUrlV1 =
  | {
      singleUrl: EnvironmentValue;
    }
  | {
      readWriteUrls: ReadWriteUrls;
    };
/**
 * Versioned schema and capabilities for a data connector.
 */
export type VersionedSchemaAndCapabilities = SchemaAndCapabilitiesV01;
/**
 * Representations of scalar types
 */
export type TypeRepresentation =
  | {
      type: 'boolean';
      [k: string]: unknown;
    }
  | {
      type: 'string';
      [k: string]: unknown;
    }
  | {
      type: 'number';
      [k: string]: unknown;
    }
  | {
      type: 'integer';
      [k: string]: unknown;
    }
  | {
      type: 'int8';
      [k: string]: unknown;
    }
  | {
      type: 'int16';
      [k: string]: unknown;
    }
  | {
      type: 'int32';
      [k: string]: unknown;
    }
  | {
      type: 'int64';
      [k: string]: unknown;
    }
  | {
      type: 'float32';
      [k: string]: unknown;
    }
  | {
      type: 'float64';
      [k: string]: unknown;
    }
  | {
      type: 'biginteger';
      [k: string]: unknown;
    }
  | {
      type: 'bigdecimal';
      [k: string]: unknown;
    }
  | {
      type: 'uuid';
      [k: string]: unknown;
    }
  | {
      type: 'date';
      [k: string]: unknown;
    }
  | {
      type: 'timestamp';
      [k: string]: unknown;
    }
  | {
      type: 'timestamptz';
      [k: string]: unknown;
    }
  | {
      type: 'geography';
      [k: string]: unknown;
    }
  | {
      type: 'geometry';
      [k: string]: unknown;
    }
  | {
      type: 'bytes';
      [k: string]: unknown;
    }
  | {
      type: 'json';
      [k: string]: unknown;
    }
  | {
      type: 'enum';
      one_of: string[];
      [k: string]: unknown;
    };
/**
 * Types track the valid representations of values as JSON
 */
export type Type =
  | {
      type: 'named';
      /**
       * The name can refer to a primitive type or a scalar type
       */
      name: string;
      [k: string]: unknown;
    }
  | {
      type: 'nullable';
      /**
       * The type of the non-null inhabitants of this type
       */
      underlying_type: Type;
      [k: string]: unknown;
    }
  | {
      type: 'array';
      /**
       * The type of the elements of the array
       */
      element_type: Type;
      [k: string]: unknown;
    }
  | {
      type: 'predicate';
      /**
       * The object type name
       */
      object_type_name: string;
      [k: string]: unknown;
    };
/**
 * The definition of a comparison operator on a scalar type
 */
export type ComparisonOperatorDefinition =
  | {
      type: 'equal';
      [k: string]: unknown;
    }
  | {
      type: 'in';
      [k: string]: unknown;
    }
  | {
      type: 'custom';
      /**
       * The type of the argument to this operator
       */
      argument_type: Type;
      [k: string]: unknown;
    };
/**
 * The name of an argument as defined by a data connector.
 */
export type DataConnectorArgumentName = string;
/**
 * An expression which evaluates to a value that can be used in permissions and various presets.
 */
export type ValueExpression = Literal | SessionVariable;
/**
 * Used to represent the name of a session variable, like "x-hasura-role".
 */
export type OpenDdSessionVariable = string;
/**
 * The name of a column in a data connector.
 */
export type DataConnectorColumnName = string;
/**
 * GraphqlConfig object tells us two things:
 *
 * 1. How the Graphql schema should look like for the features (`where`, `order_by` etc) Hasura provides 2. What features should be enabled/disabled across the subgraphs
 */
export type GraphqlConfig1 = {
  kind: 'GraphqlConfig';
  version: 'v1';
  definition: GraphqlConfigV1;
};
/**
 * Definition of a user-defined Open DD object type.
 */
export type ObjectType1 = {
  kind: 'ObjectType';
  version: 'v1';
  definition: ObjectTypeV1;
};
/**
 * The name of a user-defined type.
 */
export type CustomTypeName = string;
/**
 * The name of a field in a user-defined object type.
 */
export type FieldName = string;
/**
 * A reference to an Open DD type including nullable values and arrays.
 * Suffix '!' to indicate a non-nullable reference, and wrap in '[]' to indicate an array.
 * Eg: '[String!]!' is a non-nullable array of non-nullable strings.
 */
export type TypeReference = string;
/**
 * The name of an argument.
 */
export type ArgumentName = string;
/**
 * The name of an object type in a data connector.
 */
export type DataConnectorObjectType = string;
export type FieldMapping = {
  column: ColumnFieldMapping;
};
/**
 * Definition of a user-defined scalar type that that has opaque semantics.
 */
export type ScalarType1 = {
  kind: 'ScalarType';
  version: 'v1';
  definition: ScalarTypeV1;
};
/**
 * Definition of a type representing a boolean expression on an Open DD object type.
 */
export type ObjectBooleanExpressionType = {
  kind: 'ObjectBooleanExpressionType';
  version: 'v1';
  definition: ObjectBooleanExpressionTypeV1;
};
/**
 * Enable all or specific values.
 */
export type EnableAllOrSpecific =
  | {
      enableAll: boolean;
    }
  | {
      enableSpecific: OperatorName[];
    };
/**
 * The name of an operator
 */
export type OperatorName = string;
/**
 * Definition of a type representing a boolean expression on an OpenDD type.
 */
export type BooleanExpressionType = {
  kind: 'BooleanExpressionType';
  version: 'v1';
  definition: BooleanExpressionTypeV1;
};
/**
 * Configuration for object or scalar boolean expression
 */
export type BooleanExpressionOperand = Object | Scalar;
/**
 * The name of the GraphQL relationship field.
 */
export type RelationshipName = string;
export type TypeName = InbuiltType | CustomTypeName;
/**
 * An inbuilt primitive OpenDD type.
 */
export type InbuiltType = 'ID' | 'Int' | 'Float' | 'Boolean' | 'String';
/**
 * The name of a scalar type in a data connector.
 */
export type DataConnectorScalarType = string;
/**
 * The name of an operator in a data connector.
 */
export type DataConnectorOperatorName = string;
/**
 * The representation of a data connector scalar in terms of Open DD types
 */
export type DataConnectorScalarRepresentation = {
  kind: 'DataConnectorScalarRepresentation';
  version: 'v1';
  definition: DataConnectorScalarRepresentationV1;
};
/**
 * Definition of an aggregate expression on an OpenDD type.
 */
export type AggregateExpression = {
  kind: 'AggregateExpression';
  version: 'v1';
  definition: AggregateExpressionV1;
};
/**
 * The name of an aggregate expression.
 */
export type AggregateExpressionName = string;
/**
 * Definition of an aggregate expression's operand
 */
export type AggregateOperand = Object1 | Scalar1;
/**
 * The name of an aggregation function.
 */
export type AggregationFunctionName = string;
/**
 * The name of an aggregation function in a data connector
 */
export type DataConnectorAggregationFunctionName = string;
/**
 * The definition of a data model. A data model is a collection of objects of a particular type. Models can support one or more CRUD operations.
 */
export type Model = {
  kind: 'Model';
  version: 'v1';
  definition: ModelV1;
};
/**
 * The name of data model.
 */
export type ModelName = string;
/**
 * The name of a collection in a data connector.
 */
export type CollectionName = string;
/**
 * Enable all or specific values.
 */
export type EnableAllOrSpecific1 =
  | {
      enableAll: boolean;
    }
  | {
      enableSpecific: OrderByDirection1[];
    };
export type OrderByDirection1 = 'Asc' | 'Desc';
/**
 * The definition of a command. A command is a user-defined operation which can take arguments and returns an output. The semantics of a command are opaque to the Open DD specification.
 */
export type Command = {
  kind: 'Command';
  version: 'v1';
  definition: CommandV1;
};
/**
 * The name of a command.
 */
export type CommandName = string;
export type DataConnectorCommand = Function | Procedure;
/**
 * The name of a function backing the command.
 */
export type FunctionName = string;
/**
 * The name of a procedure backing the command.
 */
export type ProcedureName = string;
export type GraphQlRootFieldKind = 'Query' | 'Mutation';
/**
 * Definition of a relationship on an OpenDD type which allows it to be extended with related models or commands.
 */
export type Relationship = {
  kind: 'Relationship';
  version: 'v1';
  definition: RelationshipV1;
};
/**
 * The target for a relationship.
 */
export type RelationshipTarget =
  | {
      model: ModelRelationshipTarget;
    }
  | {
      command: CommandRelationshipTarget;
    };
/**
 * Type of the relationship.
 */
export type RelationshipType = 'Object' | 'Array';
/**
 * The source configuration for a relationship mapping.
 */
export type RelationshipMappingSource = SourceValue | SourceField;
/**
 * The target configuration for a relationship mapping.
 */
export type RelationshipMappingTarget = TargetArgument | TargetModelField;
/**
 * Definition of permissions for an OpenDD type.
 */
export type TypePermissions = {
  kind: 'TypePermissions';
  version: 'v1';
  definition: TypePermissionsV1;
};
/**
 * Definition of permissions for an OpenDD model.
 */
export type ModelPermissions = {
  kind: 'ModelPermissions';
  version: 'v1';
  definition: ModelPermissionsV1;
};
export type NullableModelPredicate = null | ModelPredicate;
/**
 * A predicate that can be used to restrict the objects returned when querying a model.
 */
export type ModelPredicate =
  | {
      fieldComparison: FieldComparisonPredicate;
    }
  | {
      fieldIsNull: FieldIsNullPredicate;
    }
  | {
      relationship: RelationshipPredicate;
    }
  | And
  | Or
  | Not;
/**
 * An expression which evaluates to a value that can be used in permissions and various presets.
 */
export type ValueExpressionOrPredicate =
  | Literal1
  | SessionVariable1
  | BooleanExpression;
/**
 * Definition of permissions for an OpenDD command.
 */
export type CommandPermissions = {
  kind: 'CommandPermissions';
  version: 'v1';
  definition: CommandPermissionsV1;
};
/**
 * Definition of a lifecycle plugin hook.
 */
export type LifecyclePluginHook = {
  kind: 'LifecyclePluginHook';
  version: 'v1';
  definition: LifecyclePluginHookV1;
};
/**
 * Definition of a lifecycle plugin hook - version 1.
 */
export type LifecyclePluginHookV1 = LifecyclePluginHookPreParse;
export type V2_SubgraphObject = V2_HasuraSubgraphObject | OpenDdSubgraphObject;
export type V2_HasuraSubgraphObject = V2_CompatibilityConfig | AuthConfig1;
/**
 * Definition of the authentication configuration used by the API server.
 */
export type AuthConfig1 = AuthConfigV12 | AuthConfigV22;

export interface V1_Metadata {
  version: 'v1';
  supergraph: V1_Supergraph;
  subgraphs?: V1_Subgraph[];
}
export interface V1_Supergraph {
  objects: V1_SupergraphObject[];
}
/**
 * The compatibility configuration of the Hasura metadata.
 */
export interface V1_CompatibilityConfig {
  kind: 'CompatibilityConfig';
  /**
   * Any backwards incompatible changes made to Hasura DDN after this date won't impact the metadata.
   */
  date: CompatibilityDate;
}
/**
 * Definition of the authentication configuration v1, used by the API server.
 */
export interface AuthConfigV1 {
  kind: 'AuthConfig';
  version: 'v1';
  definition: AuthConfigV11;
}
/**
 * Definition of the authentication configuration v1, used by the API server.
 */
export interface AuthConfigV11 {
  allowRoleEmulationBy?: Role | null;
  mode: AuthModeConfig;
}
/**
 * The configuration of the authentication webhook.
 */
export interface AuthHookConfig {
  /**
   * The URL of the authentication webhook.
   */
  url: string;
  /**
   * The HTTP method to be used to make the request to the auth hook.
   */
  method: AuthHookMethod;
}
/**
 * JWT config according to which the incoming JWT will be verified and decoded to extract the session variable claims.
 */
export interface JWTConfig {
  /**
   * Optional validation to check that the `aud` field is a member of the `audience` received, otherwise will throw error.
   */
  audience?: string[] | null;
  /**
   * Optional validation to check that the `iss` field is a member of the `iss` received, otherwise will throw error.
   */
  issuer?: string | null;
  /**
   * Allowed leeway (in seconds) to the `exp` validation to account for clock skew.
   */
  allowedSkew?: number | null;
  /**
   * Claims config. Either specified via `claims_mappings` or `claims_namespace_path`
   */
  claimsConfig: JWTClaimsConfig;
  /**
   * Source of the JWT authentication token.
   */
  tokenLocation: JWTTokenLocation;
  /**
   * Mode according to which the JWT auth is configured.
   */
  key: JWTKey;
}
/**
 * Can be used when Hasura claims are not all present in the single object, but individual claims are provided a JSON pointer within the decoded JWT and optionally a default value.
 */
export interface JWTClaimsMap {
  /**
   * JSON pointer to lookup the default role within the decoded JWT.
   */
  'x-hasura-default-role': JWTClaimsMappingEntry;
  /**
   * JSON pointer to lookup the allowed roles within the decoded JWT.
   */
  'x-hasura-allowed-roles': JWTClaimsMappingEntry1;
  [k: string]: unknown;
}
/**
 * Entry to lookup the Hasura claims at the specified JSON Pointer
 */
export interface JWTClaimsMappingPathEntry {
  /**
   * JSON pointer to find the particular claim in the decoded JWT token.
   */
  path: string;
  /**
   * Default value to be used when no value is found when looking up the value using the `path`.
   */
  default?: Role | null;
}
/**
 * Entry to lookup the Hasura claims at the specified JSON Pointer
 */
export interface JWTClaimsMappingPathEntry1 {
  /**
   * JSON pointer to find the particular claim in the decoded JWT token.
   */
  path: string;
  /**
   * Default value to be used when no value is found when looking up the value using the `path`.
   */
  default?: Role[] | null;
}
/**
 * Used when all of the Hasura claims are present in a single object within the decoded JWT.
 */
export interface JWTClaimsNamespace {
  /**
   * Format in which the Hasura claims will be present.
   */
  claimsFormat: JWTClaimsFormat;
  /**
   * Pointer to lookup the Hasura claims within the decoded claims.
   */
  location: string;
}
/**
 * Get the bearer token from the `Authorization` header.
 */
export interface JWTBearerAuthorizationLocation {
  type: 'BearerAuthorization';
}
/**
 * Get the token from the Cookie header under the specified cookie name.
 */
export interface JWTCookieLocation {
  type: 'Cookie';
  name: string;
}
/**
 * Custom header from where the header should be parsed from.
 */
export interface JWTHeaderLocation {
  type: 'Header';
  name: string;
}
/**
 * JWT Secret config according to which the incoming JWT will be decoded.
 */
export interface JWTKeyConfig {
  /**
   * The algorithm used to decode the JWT.
   */
  algorithm: JWTAlgorithm;
  /**
   * The key to use for decoding the JWT.
   */
  key: EnvironmentValue;
}
/**
 * Configuration used when running engine without authentication
 */
export interface NoAuthConfig {
  /**
   * role to assume whilst running the engine
   */
  role: Role;
  sessionVariables: SessionVariables;
}
/**
 * static session variables to use whilst running the engine
 */
export interface SessionVariables {
  [k: string]: SessionVariableValue;
}
/**
 * Definition of the authentication configuration v2, used by the API server.
 */
export interface AuthConfigV2 {
  kind: 'AuthConfig';
  version: 'v2';
  definition: AuthConfigV21;
}
/**
 * Definition of the authentication configuration v2, used by the API server.
 */
export interface AuthConfigV21 {
  mode: AuthModeConfig;
}
/**
 * GraphqlConfig object tells us two things:
 *
 * 1. How the Graphql schema should look like for the features (`where`, `order_by` etc) Hasura provides 2. What features should be enabled/disabled across the subgraphs
 */
export interface GraphqlConfigV1 {
  query: QueryGraphqlConfig;
  mutation: MutationGraphqlConfig;
  apolloFederation?: GraphqlApolloFederationConfig | null;
}
/**
 * Configuration for the GraphQL schema of Hasura features for queries. `None` means disable the feature.
 */
export interface QueryGraphqlConfig {
  /**
   * The name of the root operation type name for queries. Usually `query`.
   */
  rootOperationTypeName: GraphQlTypeName;
  /**
   * Configuration for the arguments input.
   */
  argumentsInput?: ArgumentsInputGraphqlConfig | null;
  /**
   * Configuration for the limit operation.
   */
  limitInput?: LimitInputGraphqlConfig | null;
  /**
   * Configuration for the offset operation.
   */
  offsetInput?: OffsetInputGraphqlConfig | null;
  /**
   * Configuration for the filter operation.
   */
  filterInput?: FilterInputGraphqlConfig | null;
  /**
   * Configuration for the sort operation.
   */
  orderByInput?: OrderByInputGraphqlConfig | null;
  /**
   * Configuration for aggregates
   */
  aggregate?: AggregateGraphqlConfig | null;
}
/**
 * Configuration for the arguments input.
 */
export interface ArgumentsInputGraphqlConfig {
  /**
   * The name of arguments passing field. Usually `args`.
   */
  fieldName: GraphQlFieldName;
}
/**
 * Configuration for the limit operation.
 */
export interface LimitInputGraphqlConfig {
  /**
   * The name of the limit operation field. Usually `limit`.
   */
  fieldName: GraphQlFieldName;
}
/**
 * Configuration for the offset operation.
 */
export interface OffsetInputGraphqlConfig {
  /**
   * The name of the offset operation field. Usually `offset`.
   */
  fieldName: GraphQlFieldName;
}
/**
 * Configuration for the filter operation.
 */
export interface FilterInputGraphqlConfig {
  /**
   * The name of the filter operation field. Usually `where`.
   */
  fieldName: GraphQlFieldName;
  /**
   * The names of built-in filter operators.
   */
  operatorNames: FilterInputOperatorNames;
}
/**
 * The names of built-in filter operators.
 */
export interface FilterInputOperatorNames {
  /**
   * The name of the `and` operator. Usually `_and`.
   */
  and: GraphQlFieldName;
  /**
   * The name of the `or` operator. Usually `_or`.
   */
  or: GraphQlFieldName;
  /**
   * The name of the `not` operator. Usually `_not`.
   */
  not: GraphQlFieldName;
  /**
   * The name of the `is null` operator. Usually `_is_null`.
   */
  isNull: GraphQlFieldName;
}
/**
 * Configuration for the sort operation.
 */
export interface OrderByInputGraphqlConfig {
  /**
   * The name of the filter operation field. Usually `order_by`.
   */
  fieldName: GraphQlFieldName;
  /**
   * The names of the direction parameters.
   */
  enumDirectionValues: OrderByDirectionValues;
  enumTypeNames: OrderByEnumTypeName[];
}
/**
 * The names of the direction parameters.
 */
export interface OrderByDirectionValues {
  /**
   * The name of the ascending parameter. Usually `Asc`.
   */
  asc: GraphQlFieldName;
  /**
   * The name of the descending parameter. Usually `Desc`.
   */
  desc: GraphQlFieldName;
}
/**
 * Type name for a sort directions enum, with the given set of possible directions.
 */
export interface OrderByEnumTypeName {
  directions: OrderByDirection[];
  typeName: GraphQlTypeName;
}
/**
 * Configuration for the GraphQL schema for aggregates.
 */
export interface AggregateGraphqlConfig {
  /**
   * The name of the filter input parameter of aggregate fields and field name in predicates
   */
  filterInputFieldName: GraphQlFieldName;
  /**
   * The name of the _count field used for the count aggregate function
   */
  countFieldName: GraphQlFieldName;
  /**
   * The name of the _count_distinct field used for the count distinct aggregate function
   */
  countDistinctFieldName: GraphQlFieldName;
}
/**
 * Configuration for the GraphQL schema of Hasura features for mutations.
 */
export interface MutationGraphqlConfig {
  /**
   * The name of the root operation type name for mutations. Usually `mutation`.
   */
  rootOperationTypeName: GraphQlTypeName;
}
/**
 * Configuration for the GraphQL schema of Hasura features for Apollo Federation.
 */
export interface GraphqlApolloFederationConfig {
  /**
   * Adds the `_entities` and `_services` root fields required for Apollo Federation.
   */
  enableRootFields: boolean;
}
export interface V1_Subgraph {
  name: string;
  objects: V1_SubgraphObject[];
}
/**
 * Definition of a data connector - version 1.
 */
export interface DataConnectorLinkV1 {
  /**
   * The name of the data connector.
   */
  name: DataConnectorName;
  /**
   * The url(s) to access the data connector.
   */
  url: DataConnectorUrlV1;
  /**
   * Key value map of HTTP headers to be sent with each request to the data connector. This is meant for protocol level use between engine and the data connector.
   */
  headers?: HttpHeaders;
  /**
   * The schema of the data connector. This schema is used as the source of truth when serving requests and the live schema of the data connector is not looked up.
   */
  schema: VersionedSchemaAndCapabilities;
  /**
   * Argument presets that applies to all functions and procedures of this data connector. Defaults to no argument presets.
   */
  argumentPresets?: DataConnectorArgumentPreset[];
  /**
   * HTTP response headers configuration that is forwarded from a data connector to the client.
   */
  responseHeaders?: ResponseHeaders | null;
}
/**
 * A pair of URLs to access a data connector, one for reading and one for writing.
 */
export interface ReadWriteUrls {
  read: EnvironmentValue;
  write: EnvironmentValue;
}
/**
 * Key value map of HTTP headers to be sent with an HTTP request. The key is the header name and the value is a potential reference to an environment variable.
 */
export interface HttpHeaders {
  [k: string]: EnvironmentValue;
}
/**
 * Version 0.1 of schema and capabilities for a data connector.
 */
export interface SchemaAndCapabilitiesV01 {
  version: 'v0.1';
  schema: SchemaResponse;
  capabilities: CapabilitiesResponse;
}
export interface SchemaResponse {
  /**
   * A list of scalar types which will be used as the types of collection columns
   */
  scalar_types: {
    [k: string]: ScalarType;
  };
  /**
   * A list of object types which can be used as the types of arguments, or return types of procedures. Names should not overlap with scalar type names.
   */
  object_types: {
    [k: string]: ObjectType;
  };
  /**
   * Collections which are available for queries
   */
  collections: CollectionInfo[];
  /**
   * Functions (i.e. collections which return a single column and row)
   */
  functions: FunctionInfo[];
  /**
   * Procedures which are available for execution as part of mutations
   */
  procedures: ProcedureInfo[];
  [k: string]: unknown;
}
/**
 * The definition of a scalar type, i.e. types that can be used as the types of columns.
 */
export interface ScalarType {
  /**
   * A description of valid values for this scalar type. Defaults to `TypeRepresentation::JSON` if omitted
   */
  representation?: TypeRepresentation | null;
  /**
   * A map from aggregate function names to their definitions. Result type names must be defined scalar types declared in ScalarTypesCapabilities.
   */
  aggregate_functions: {
    [k: string]: AggregateFunctionDefinition;
  };
  /**
   * A map from comparison operator names to their definitions. Argument type names must be defined scalar types declared in ScalarTypesCapabilities.
   */
  comparison_operators: {
    [k: string]: ComparisonOperatorDefinition;
  };
  [k: string]: unknown;
}
/**
 * The definition of an aggregation function on a scalar type
 */
export interface AggregateFunctionDefinition {
  /**
   * The scalar or object type of the result of this function
   */
  result_type: Type;
  [k: string]: unknown;
}
/**
 * The definition of an object type
 */
export interface ObjectType {
  /**
   * Description of this type
   */
  description?: string | null;
  /**
   * Fields defined on this object type
   */
  fields: {
    [k: string]: ObjectField;
  };
  [k: string]: unknown;
}
/**
 * The definition of an object field
 */
export interface ObjectField {
  /**
   * Description of this field
   */
  description?: string | null;
  /**
   * The type of this field
   */
  type: Type;
  /**
   * The arguments available to the field - Matches implementation from CollectionInfo
   */
  arguments?: {
    [k: string]: ArgumentInfo;
  };
  [k: string]: unknown;
}
export interface ArgumentInfo {
  /**
   * Argument description
   */
  description?: string | null;
  /**
   * The name of the type of this argument
   */
  type: Type;
  [k: string]: unknown;
}
export interface CollectionInfo {
  /**
   * The name of the collection
   *
   * Note: these names are abstract - there is no requirement that this name correspond to the name of an actual collection in the database.
   */
  name: string;
  /**
   * Description of the collection
   */
  description?: string | null;
  /**
   * Any arguments that this collection requires
   */
  arguments: {
    [k: string]: ArgumentInfo;
  };
  /**
   * The name of the collection's object type
   */
  type: string;
  /**
   * Any uniqueness constraints enforced on this collection
   */
  uniqueness_constraints: {
    [k: string]: UniquenessConstraint;
  };
  /**
   * Any foreign key constraints enforced on this collection
   */
  foreign_keys: {
    [k: string]: ForeignKeyConstraint;
  };
  [k: string]: unknown;
}
export interface UniquenessConstraint {
  /**
   * A list of columns which this constraint requires to be unique
   */
  unique_columns: string[];
  [k: string]: unknown;
}
export interface ForeignKeyConstraint {
  /**
   * The columns on which you want want to define the foreign key.
   */
  column_mapping: {
    [k: string]: string;
  };
  /**
   * The name of a collection
   */
  foreign_collection: string;
  [k: string]: unknown;
}
export interface FunctionInfo {
  /**
   * The name of the function
   */
  name: string;
  /**
   * Description of the function
   */
  description?: string | null;
  /**
   * Any arguments that this collection requires
   */
  arguments: {
    [k: string]: ArgumentInfo;
  };
  /**
   * The name of the function's result type
   */
  result_type: Type;
  [k: string]: unknown;
}
export interface ProcedureInfo {
  /**
   * The name of the procedure
   */
  name: string;
  /**
   * Column description
   */
  description?: string | null;
  /**
   * Any arguments that this collection requires
   */
  arguments: {
    [k: string]: ArgumentInfo;
  };
  /**
   * The name of the result type
   */
  result_type: Type;
  [k: string]: unknown;
}
export interface CapabilitiesResponse {
  version: string;
  capabilities: Capabilities;
  [k: string]: unknown;
}
/**
 * Describes the features of the specification which a data connector implements.
 */
export interface Capabilities {
  query: QueryCapabilities;
  mutation: MutationCapabilities;
  relationships?: RelationshipCapabilities | null;
  [k: string]: unknown;
}
export interface QueryCapabilities {
  /**
   * Does the connector support aggregate queries
   */
  aggregates?: LeafCapability | null;
  /**
   * Does the connector support queries which use variables
   */
  variables?: LeafCapability | null;
  /**
   * Does the connector support explaining queries
   */
  explain?: LeafCapability | null;
  /**
   * Does the connector support nested fields
   */
  nested_fields?: NestedFieldCapabilities;
  [k: string]: unknown;
}
/**
 * A unit value to indicate a particular leaf capability is supported. This is an empty struct to allow for future sub-capabilities.
 */
export interface LeafCapability {
  [k: string]: unknown;
}
export interface NestedFieldCapabilities {
  /**
   * Does the connector support filtering by values of nested fields
   */
  filter_by?: LeafCapability | null;
  /**
   * Does the connector support ordering by values of nested fields
   */
  order_by?: LeafCapability | null;
  /**
   * Does the connector support aggregating values within nested fields
   */
  aggregates?: LeafCapability | null;
  [k: string]: unknown;
}
export interface MutationCapabilities {
  /**
   * Does the connector support executing multiple mutations in a transaction.
   */
  transactional?: LeafCapability | null;
  /**
   * Does the connector support explaining mutations
   */
  explain?: LeafCapability | null;
  [k: string]: unknown;
}
export interface RelationshipCapabilities {
  /**
   * Does the connector support comparisons that involve related collections (ie. joins)?
   */
  relation_comparisons?: LeafCapability | null;
  /**
   * Does the connector support ordering by an aggregated array relationship?
   */
  order_by_aggregate?: LeafCapability | null;
  [k: string]: unknown;
}
/**
 * An argument preset that can be applied to all functions/procedures of a connector
 */
export interface DataConnectorArgumentPreset {
  argument: DataConnectorArgumentName;
  value: DataConnectorArgumentPresetValue;
}
/**
 * The value of a data connector argument preset.
 */
export interface DataConnectorArgumentPresetValue {
  /**
   * HTTP headers that can be preset from request
   */
  httpHeaders: HttpHeadersPreset;
}
/**
 * Configuration of what HTTP request headers should be forwarded to a data connector.
 */
export interface HttpHeadersPreset {
  /**
   * List of HTTP headers that should be forwarded from HTTP requests
   */
  forward: string[];
  /**
   * Additional headers that should be forwarded, from other contexts
   */
  additional: AdditionalHttpHeaders;
}
/**
 * Key value map of HTTP headers to be forwarded in the headers argument of a data connector request.
 */
export interface AdditionalHttpHeaders {
  [k: string]: ValueExpression;
}
export interface Literal {
  literal: unknown;
}
export interface SessionVariable {
  sessionVariable: OpenDdSessionVariable;
}
/**
 * Configuration of what HTTP response headers should be forwarded from a data connector to the client in HTTP response.
 */
export interface ResponseHeaders {
  /**
   * Name of the field in the NDC function/procedure's result which contains the response headers
   */
  headersField: DataConnectorColumnName;
  /**
   * Name of the field in the NDC function/procedure's result which contains the result
   */
  resultField: DataConnectorColumnName;
  /**
   * List of actual HTTP response headers from the data connector to be set as response headers
   */
  forwardHeaders: string[];
}
/**
 * Definition of a user-defined Open DD object type.
 */
export interface ObjectTypeV1 {
  /**
   * The name to give this object type, used to refer to it elsewhere in the metadata. Must be unique across all types defined in this subgraph.
   */
  name: CustomTypeName;
  /**
   * The list of fields defined for this object type.
   */
  fields: ObjectFieldDefinition[];
  /**
   * The subset of fields that uniquely identify this object in the domain. Setting this property will automatically implement the GraphQL Relay Node interface for this object type and add an `id` global ID field. If setting this property, there must not be a field named `id` already present.
   */
  globalIdFields?: FieldName[] | null;
  /**
   * Configuration for how this object type should appear in the GraphQL schema.
   */
  graphql?: ObjectTypeGraphQLConfiguration | null;
  /**
   * The description of the object. Gets added to the description of the object's definition in the graphql schema.
   */
  description?: string | null;
  /**
   * Mapping of this object type to corresponding object types in various data connectors.
   */
  dataConnectorTypeMapping?: DataConnectorTypeMapping[];
}
/**
 * The definition of a field in a user-defined object type.
 */
export interface ObjectFieldDefinition {
  /**
   * The name of the field. This name is used both when referring to the field elsewhere in the metadata and when creating the corresponding GraphQl type.
   */
  name: FieldName;
  /**
   * The type of this field. This uses the GraphQL syntax to represent field types and must refer to one of the inbuilt OpenDd types or another user-defined type.
   */
  type: TypeReference;
  /**
   * The description of this field. Gets added to the description of the field's definition in the graphql schema.
   */
  description?: string | null;
  /**
   * Whether this field is deprecated. If set, the deprecation status is added to the field's graphql schema.
   */
  deprecated?: Deprecated | null;
  /**
   * The arguments for the field
   */
  arguments?: FieldArgumentDefinition[];
}
/**
 * OpenDd configuration to indicate whether an object type field, relationship, model root field or command root field is deprecated.
 */
export interface Deprecated {
  /**
   * The reason for deprecation.
   */
  reason?: string | null;
}
/**
 * The definition of an argument for a field in a user-defined object type.
 */
export interface FieldArgumentDefinition {
  name: ArgumentName;
  argumentType: TypeReference;
  description?: string | null;
}
/**
 * GraphQL configuration of an Open DD object type.
 */
export interface ObjectTypeGraphQLConfiguration {
  /**
   * The name to use for the GraphQL type representation of this object type when used in an output context.
   */
  typeName?: GraphQlTypeName | null;
  /**
   * The name to use for the GraphQL type representation of this object type when used in an input context.
   */
  inputTypeName?: GraphQlTypeName | null;
  /**
   * Configuration for exposing apollo federation related types and directives.
   */
  apolloFederation?: ObjectApolloFederationConfig | null;
}
/**
 * Configuration for apollo federation related types and directives.
 */
export interface ObjectApolloFederationConfig {
  keys: ApolloFederationObjectKey[];
}
/**
 * The definition of a key for an apollo federation object.
 */
export interface ApolloFederationObjectKey {
  fields: FieldName[];
}
/**
 * This defines the mapping of the fields of an object type to the corresponding columns of an object type in a data connector.
 */
export interface DataConnectorTypeMapping {
  dataConnectorName: DataConnectorName;
  dataConnectorObjectType: DataConnectorObjectType;
  fieldMapping?: FieldMappings;
}
/**
 * Mapping of object fields to their source columns in the data connector.
 */
export interface FieldMappings {
  [k: string]: FieldMapping;
}
/**
 * The target column in a data connector object that a source field maps to.
 */
export interface ColumnFieldMapping {
  /**
   * The name of the target column
   */
  name: DataConnectorColumnName;
  /**
   * Arguments to the column field
   */
  argumentMapping?: ArgumentMapping | null;
}
/**
 * Mapping of a comand or model argument name to the corresponding argument name used in the data connector. The key of this object is the argument name used in the command or model and the value is the argument name used in the data connector.
 */
export interface ArgumentMapping {
  [k: string]: DataConnectorArgumentName;
}
/**
 * Definition of a user-defined scalar type that that has opaque semantics.
 */
export interface ScalarTypeV1 {
  /**
   * The name to give this scalar type, used to refer to it elsewhere in the metadata. Must be unique across all types defined in this subgraph.
   */
  name: CustomTypeName;
  /**
   * Configuration for how this scalar type should appear in the GraphQL schema.
   */
  graphql?: ScalarTypeGraphQLConfiguration | null;
  /**
   * The description of this scalar. Gets added to the description of the scalar's definition in the graphql schema.
   */
  description?: string | null;
}
/**
 * GraphQL configuration of an Open DD scalar type
 */
export interface ScalarTypeGraphQLConfiguration {
  /**
   * The name of the GraphQl type to use for this scalar.
   */
  typeName: GraphQlTypeName;
}
/**
 * Definition of a type representing a boolean expression on an Open DD object type. Deprecated in favour of `BooleanExpressionType`.
 */
export interface ObjectBooleanExpressionTypeV1 {
  /**
   * The name to give this object boolean expression type, used to refer to it elsewhere in the metadata. Must be unique across all types defined in this subgraph.
   */
  name: CustomTypeName;
  /**
   * The name of the object type that this boolean expression applies to.
   */
  objectType: CustomTypeName;
  /**
   * The data connector this boolean expression type is based on.
   */
  dataConnectorName: DataConnectorName;
  /**
   * The object type in the data connector's schema this boolean expression type is based on.
   */
  dataConnectorObjectType: DataConnectorObjectType;
  /**
   * The list of fields of the object type that can be used for comparison when evaluating this boolean expression.
   */
  comparableFields: ComparableField[];
  /**
   * Configuration for how this object type should appear in the GraphQL schema.
   */
  graphql?: ObjectBooleanExpressionTypeGraphQlConfiguration | null;
}
/**
 * A field of an object type that can be used for comparison when evaluating a boolean expression.
 */
export interface ComparableField {
  fieldName: FieldName;
  operators: EnableAllOrSpecific;
}
/**
 * GraphQL configuration of an Open DD boolean expression type.
 */
export interface ObjectBooleanExpressionTypeGraphQlConfiguration {
  /**
   * The name to use for the GraphQL type representation of this boolean expression type.
   */
  typeName: GraphQlTypeName;
}
/**
 * Definition of a type representing a boolean expression on an OpenDD object type.
 */
export interface BooleanExpressionTypeV1 {
  /**
   * The name to give this boolean expression type, used to refer to it elsewhere in the metadata. Must be unique across all types defined in this subgraph.
   */
  name: CustomTypeName;
  /**
   * The type that this boolean expression applies to.
   */
  operand: BooleanExpressionOperand;
  /**
   * Whether to enable _and / _or / _not
   */
  logicalOperators: BooleanExpressionLogicalOperators;
  /**
   * Whether to enable _is_null
   */
  isNull: BooleanExpressionIsNull;
  /**
   * Configuration for how this object type should appear in the GraphQL schema.
   */
  graphql?: BooleanExpressionTypeGraphQlConfiguration | null;
}
/**
 * Definition of a boolean expression on an OpenDD object type
 */
export interface Object {
  object: BooleanExpressionObjectOperand;
}
/**
 * Definition of an object type representing a boolean expression on an OpenDD object type.
 */
export interface BooleanExpressionObjectOperand {
  /**
   * The name of the object type that this boolean expression applies to.
   */
  type: CustomTypeName;
  /**
   * The list of fields of the object type that can be used for comparison when evaluating this boolean expression.
   */
  comparableFields: BooleanExpressionComparableField[];
  /**
   * The list of relationships of the object type that can be used for comparison when evaluating this boolean expression.
   */
  comparableRelationships: BooleanExpressionComparableRelationship[];
}
/**
 * Comparison configuration definition for a field that can be used for a comparison
 */
export interface BooleanExpressionComparableField {
  fieldName: FieldName;
  booleanExpressionType: CustomTypeName;
}
/**
 * Definition of a relationship that can be used for a comparison
 */
export interface BooleanExpressionComparableRelationship {
  /**
   * The name of the relationship to use for comparison
   */
  relationshipName: RelationshipName;
  /**
   * The boolean expression type to use for comparison. This is optional for relationships to models, and defaults to the filterExpressionType of the model
   */
  booleanExpressionType?: CustomTypeName | null;
}
/**
 * Definition of a boolean expression on a scalar tyoe
 */
export interface Scalar {
  scalar: BooleanExpressionScalarOperand;
}
/**
 * Definition of a scalar type representing a boolean expression on an OpenDD object type.
 */
export interface BooleanExpressionScalarOperand {
  /**
   * The OpenDD type name of the scalar type that this boolean expression applies to.
   */
  type: TypeName;
  /**
   * The list of comparison operators that can used on this scalar type
   */
  comparisonOperators: ComparisonOperator[];
  /**
   * The list of mappings between OpenDD operator names and the names used in the data connector schema
   */
  dataConnectorOperatorMapping: DataConnectorOperatorMapping[];
}
/**
 * Definition of a comparison operator for a scalar type
 */
export interface ComparisonOperator {
  /**
   * Name you want to give the operator in OpenDD / GraphQL
   */
  name: OperatorName;
  /**
   * An OpenDD type
   */
  argumentType: TypeReference;
}
/**
 * Mapping between OpenDD operator names and the names used in the data connector schema
 */
export interface DataConnectorOperatorMapping {
  /**
   * Name of the data connector this mapping applies to
   */
  dataConnectorName: DataConnectorName;
  /**
   * Name of the scalar type according to the data connector's schema
   */
  dataConnectorScalarType: DataConnectorScalarType;
  operatorMapping: OperatorMapping;
}
/**
 * Mapping between OpenDD operator names and the data connector's operator names Defaults to the same operator name (e.g. "_eq: _eq") if no explicit mapping is present.
 */
export interface OperatorMapping {
  [k: string]: DataConnectorOperatorName;
}
/**
 * Configuration for logical operators in boolean expressions
 */
export interface BooleanExpressionLogicalOperators {
  enable: boolean;
}
/**
 * Configuration for is_null in boolean expressions
 */
export interface BooleanExpressionIsNull {
  enable: boolean;
}
/**
 * GraphQL configuration of an OpenDD boolean expression type.
 */
export interface BooleanExpressionTypeGraphQlConfiguration {
  /**
   * The name to use for the GraphQL type representation of this boolean expression type.
   */
  typeName: GraphQlTypeName;
}
/**
 * The representation of a data connector scalar in terms of Open DD types. Deprecated in favour of `BooleanExpressionType`.
 */
export interface DataConnectorScalarRepresentationV1 {
  /**
   * The name of the data connector that this scalar type comes from.
   */
  dataConnectorName: DataConnectorName;
  /**
   * The name of the scalar type coming from the data connector.
   */
  dataConnectorScalarType: DataConnectorScalarType;
  /**
   * The name of the Open DD type that this data connector scalar type should be represented as.
   */
  representation: TypeName;
  /**
   * Configuration for how this scalar's operators should appear in the GraphQL schema.
   */
  graphql?: DataConnectorScalarGraphQLConfiguration | null;
}
/**
 * GraphQL configuration of a data connector scalar
 */
export interface DataConnectorScalarGraphQLConfiguration {
  comparisonExpressionTypeName?: GraphQlTypeName | null;
}
/**
 * Definition of how to aggregate over a particular operand type
 */
export interface AggregateExpressionV1 {
  /**
   * The name of the aggregate expression.
   */
  name: AggregateExpressionName;
  /**
   * The type this aggregation expression aggregates over, and its associated configuration
   */
  operand: AggregateOperand;
  /**
   * Configuration for the count aggregate function used over the operand
   */
  count?: AggregateCountDefinition | null;
  /**
   * Configuration for the count distinct aggregate function used over the operand
   */
  countDistinct?: AggregateCountDefinition | null;
  /**
   * Configuration for how this command should appear in the GraphQL schema.
   */
  graphql?: AggregateExpressionGraphQlDefinition | null;
  /**
   * The description of the aggregate expression. Gets added to the description of the command's root field in the GraphQL schema.
   */
  description?: string | null;
}
/**
 * If the operand is an object type
 */
export interface Object1 {
  object: ObjectAggregateOperand;
}
/**
 * Definition of an aggregate over an object-typed operand
 */
export interface ObjectAggregateOperand {
  /**
   * The name of the object type the aggregate expression is aggregating
   */
  aggregatedType: CustomTypeName;
  /**
   * The fields on the object that are aggregatable
   */
  aggregatableFields: AggregatableFieldDefinition[];
}
/**
 * Definition of an aggregatable field on an object type
 */
export interface AggregatableFieldDefinition {
  /**
   * The name of the field on the operand aggregated type that is aggregatable
   */
  fieldName: FieldName;
  /**
   * A description of the aggregatable field. Gets added to the description of the field in the GraphQL schema.
   */
  description?: string | null;
  /**
   * The aggregate expression used to aggregate the type of the field
   */
  aggregateExpression: AggregateExpressionName;
}
/**
 * If the operand is a scalar type
 */
export interface Scalar1 {
  scalar: ScalarAggregateOperand;
}
/**
 * Definition of an aggregate over a scalar-typed operand
 */
export interface ScalarAggregateOperand {
  /**
   * The name of the scalar type the aggregate expression is aggregating
   */
  aggregatedType: TypeName;
  /**
   * The aggregation functions that operate over the scalar type
   */
  aggregationFunctions: AggregationFunctionDefinition[];
  /**
   * Mapping of aggregation functions to corresponding aggregation functions in various data connectors
   */
  dataConnectorAggregationFunctionMapping: DataConnectorAggregationFunctionMapping[];
}
/**
 * Definition of an aggregation function
 */
export interface AggregationFunctionDefinition {
  /**
   * The name of the aggregation function
   */
  name: AggregationFunctionName;
  /**
   * A description of the aggregation function. Gets added to the description of the field in the GraphQL schema.
   */
  description?: string | null;
  returnType: TypeReference;
}
/**
 * Definition of how to map an aggregate expression's aggregation functions to data connector aggregation functions.
 */
export interface DataConnectorAggregationFunctionMapping {
  /**
   * The data connector being mapped to
   */
  dataConnectorName: DataConnectorName;
  /**
   * The matching scalar type in the data connector for the operand scalar type
   */
  dataConnectorScalarType: DataConnectorScalarType;
  /**
   * Mapping from Open DD aggregation function to data connector aggregation function
   */
  functionMapping: AggregationFunctionMappings;
}
/**
 * Mapping of aggregation functions to their matching aggregation functions in the data connector.
 */
export interface AggregationFunctionMappings {
  [k: string]: AggregateFunctionMapping;
}
/**
 * Definition of how to map the aggregation function to a function in the data connector
 */
export interface AggregateFunctionMapping {
  /**
   * The name of the aggregation function in the data connector
   */
  name: DataConnectorAggregationFunctionName;
}
/**
 * Definition of a count aggregation function
 */
export interface AggregateCountDefinition {
  /**
   * Whether or not the aggregate function is available for use or not
   */
  enable: boolean;
  /**
   * A description of the aggregation function. Gets added to the description of the field in the GraphQL schema.
   */
  description?: string | null;
}
/**
 * The definition of how an aggregate expression should appear in the GraphQL API.
 */
export interface AggregateExpressionGraphQlDefinition {
  /**
   * The type name to use for the aggregate selection type
   */
  selectTypeName: GraphQlTypeName;
  /**
   * Whether this command root field is deprecated. If set, this will be added to the graphql schema as a deprecated field.
   */
  deprecated?: Deprecated | null;
}
/**
 * The definition of a data model. A data model is a collection of objects of a particular type. Models can support one or more CRUD operations.
 */
export interface ModelV1 {
  /**
   * The name of the data model.
   */
  name: ModelName;
  /**
   * The type of the objects of which this model is a collection.
   */
  objectType: CustomTypeName;
  /**
   * Whether this model should be used as the global ID source for all objects of its type.
   */
  globalIdSource?: boolean;
  /**
   * A list of arguments accepted by this model. Defaults to no arguments.
   */
  arguments?: ArgumentDefinition[];
  /**
   * The source configuration for this model.
   */
  source?: ModelSource | null;
  /**
   * The boolean expression type that should be used to perform filtering on this model.
   */
  filterExpressionType?: CustomTypeName | null;
  /**
   * A list of fields that can be used to order the objects in this model.
   */
  orderableFields: OrderableField[];
  /**
   * The name of the AggregateExpression that defines how to aggregate over this model
   */
  aggregateExpression?: AggregateExpressionName | null;
  /**
   * Configuration for how this model should appear in the GraphQL schema.
   */
  graphql?: ModelGraphQlDefinition | null;
  /**
   * The description of the model. Gets added to the description of the model in the graphql schema.
   */
  description?: string | null;
}
/**
 * The definition of an argument for a field, command, or model.
 */
export interface ArgumentDefinition {
  name: ArgumentName;
  type: TypeReference;
  description?: string | null;
}
/**
 * Description of how a model maps to a particular data connector
 */
export interface ModelSource {
  /**
   * The name of the data connector backing this model.
   */
  dataConnectorName: DataConnectorName;
  /**
   * The collection in the data connector that backs this model.
   */
  collection: CollectionName;
  /**
   * Mapping from model argument names to data connector collection argument names.
   */
  argumentMapping?: ArgumentMapping;
}
/**
 * A field that can be used to order the objects in a model.
 */
export interface OrderableField {
  fieldName: FieldName;
  orderByDirections: EnableAllOrSpecific1;
}
/**
 * The definition of how a model appears in the GraphQL API.
 */
export interface ModelGraphQlDefinition {
  /**
   * For each select unique defined here, a query root field is added to the GraphQL API that can be used to select a unique object from the model.
   */
  selectUniques: SelectUniqueGraphQlDefinition[];
  /**
   * Select many configuration for a model adds a query root field to the GraphQl API that can be used to retrieve multiple objects from the model.
   */
  selectMany?: SelectManyGraphQlDefinition | null;
  /**
   * The type name of the input type used to hold the arguments of the model.
   */
  argumentsInputType?: GraphQlTypeName | null;
  /**
   * The type name of the order by expression input type.
   */
  orderByExpressionType?: GraphQlTypeName | null;
  /**
   * Apollo Federation configuration
   */
  apolloFederation?: ModelApolloFederationConfiguration | null;
  /**
   * The type name of the input type used to hold the filtering settings used by aggregates (etc) to filter their input before processing
   */
  filterInputTypeName?: GraphQlTypeName | null;
  /**
   * Configures the query root field added to the GraphQL API that can be used to aggregate over the model
   */
  aggregate?: ModelAggregateGraphQlDefinition | null;
}
/**
 * The definition of the GraphQL API for selecting a unique row/object from a model.
 */
export interface SelectUniqueGraphQlDefinition {
  /**
   * The name of the query root field for this API.
   */
  queryRootField: GraphQlFieldName;
  /**
   * A set of fields which can uniquely identify a row/object in the model.
   */
  uniqueIdentifier: FieldName[];
  /**
   * The description of the select unique graphql definition of the model. Gets added to the description of the select unique root field of the model in the graphql schema.
   */
  description?: string | null;
  /**
   * Whether this select unique query field is deprecated. If set, the deprecation status is added to the select unique root field's graphql schema.
   */
  deprecated?: Deprecated | null;
}
/**
 * The definition of the GraphQL API for selecting rows from a model.
 */
export interface SelectManyGraphQlDefinition {
  /**
   * The name of the query root field for this API.
   */
  queryRootField: GraphQlFieldName;
  /**
   * The description of the select many graphql definition of the model. Gets added to the description of the select many root field of the model in the graphql schema.
   */
  description?: string | null;
  /**
   * Whether this select many query field is deprecated. If set, the deprecation status is added to the select many root field's graphql schema.
   */
  deprecated?: Deprecated | null;
}
/**
 * Apollo Federation configuration for a model.
 */
export interface ModelApolloFederationConfiguration {
  /**
   * Whether this model should be used as the source for fetching _entity for object of its type.
   */
  entitySource: boolean;
}
/**
 * The definition of the GraphQL API for aggregating over a model.
 */
export interface ModelAggregateGraphQlDefinition {
  /**
   * The name of the query root field for this API.
   */
  queryRootField: GraphQlFieldName;
  /**
   * The description of the aggregate graphql definition of the model. Gets added to the description of the aggregate root field of the model in the graphql schema.
   */
  description?: string | null;
  /**
   * Whether this aggregate query field is deprecated. If set, the deprecation status is added to the aggregate root field's graphql schema.
   */
  deprecated?: Deprecated | null;
}
/**
 * Definition of an OpenDD Command, which is a custom operation that can take arguments and returns an output. The semantics of a command are opaque to OpenDD.
 */
export interface CommandV1 {
  /**
   * The name of the command.
   */
  name: CommandName;
  /**
   * The return type of the command.
   */
  outputType: TypeReference;
  /**
   * The list of arguments accepted by this command. Defaults to no arguments.
   */
  arguments?: ArgumentDefinition[];
  /**
   * The source configuration for this command.
   */
  source?: CommandSource | null;
  /**
   * Configuration for how this command should appear in the GraphQL schema.
   */
  graphql?: CommandGraphQlDefinition | null;
  /**
   * The description of the command. Gets added to the description of the command's root field in the GraphQL schema.
   */
  description?: string | null;
}
/**
 * Description of how a command maps to a particular data connector
 */
export interface CommandSource {
  /**
   * The name of the data connector backing this command.
   */
  dataConnectorName: DataConnectorName;
  /**
   * The function/procedure in the data connector that backs this command.
   */
  dataConnectorCommand: DataConnectorCommand;
  /**
   * Mapping from command argument names to data connector function or procedure argument names.
   */
  argumentMapping?: ArgumentMapping;
}
/**
 * A function as data connector command.
 */
export interface Function {
  function: FunctionName;
}
/**
 * A procedure as data connector command.
 */
export interface Procedure {
  procedure: ProcedureName;
}
/**
 * The definition of how a command should appear in the GraphQL API.
 */
export interface CommandGraphQlDefinition {
  /**
   * The name of the graphql root field to use for this command.
   */
  rootFieldName: GraphQlFieldName;
  /**
   * Whether to put this command in the Query or Mutation root of the GraphQL API.
   */
  rootFieldKind: GraphQlRootFieldKind;
  /**
   * Whether this command root field is deprecated. If set, this will be added to the graphql schema as a deprecated field.
   */
  deprecated?: Deprecated | null;
}
/**
 * Definition of a relationship on an OpenDD type which allows it to be extended with related models or commands.
 */
export interface RelationshipV1 {
  /**
   * The name of the relationship.
   */
  name: RelationshipName;
  /**
   * The source type of the relationship.
   */
  sourceType: CustomTypeName;
  /**
   * The target of the relationship.
   */
  target: RelationshipTarget;
  /**
   * The mapping configuration of source to target for the relationship.
   */
  mapping: RelationshipMapping[];
  /**
   * The description of the relationship. Gets added to the description of the relationship in the graphql schema.
   */
  description?: string | null;
  /**
   * Whether this relationship is deprecated. If set, the deprecation status is added to the relationship field's graphql schema.
   */
  deprecated?: Deprecated | null;
  /**
   * Configuration for how this relationship should appear in the GraphQL schema.
   */
  graphql?: RelationshipGraphQlDefinition | null;
}
/**
 * The target model for a relationship.
 */
export interface ModelRelationshipTarget {
  /**
   * The name of the data model.
   */
  name: ModelName;
  /**
   * The subgraph of the target model. Defaults to the current subgraph.
   */
  subgraph?: string | null;
  /**
   * Type of the relationship - object or array.
   */
  relationshipType: RelationshipType;
  /**
   * How to aggregate over the relationship. Only valid for array relationships
   */
  aggregate?: ModelRelationshipTargetAggregate | null;
}
/**
 * Which aggregate expression to use to aggregate the array relationship.
 */
export interface ModelRelationshipTargetAggregate {
  /**
   * The name of the aggregate expression that defines how to aggregate across the relationship.
   */
  aggregateExpression: AggregateExpressionName;
  /**
   * The description of the relationship aggregate. Gets added to the description of the aggregate field in the GraphQL schema
   */
  description?: string | null;
}
/**
 * The target command for a relationship.
 */
export interface CommandRelationshipTarget {
  /**
   * The name of the command.
   */
  name: CommandName;
  /**
   * The subgraph of the target command. Defaults to the current subgraph.
   */
  subgraph?: string | null;
}
/**
 * Definition of a how a particular field in the source maps to a target field or argument.
 */
export interface RelationshipMapping {
  /**
   * The source configuration for this relationship mapping.
   */
  source: RelationshipMappingSource;
  /**
   * The target configuration for this relationship mapping.
   */
  target: RelationshipMappingTarget;
}
export interface SourceValue {
  value: ValueExpression;
}
export interface SourceField {
  fieldPath: RelationshipSourceFieldAccess[];
}
/**
 * A field access in a relationship mapping.
 */
export interface RelationshipSourceFieldAccess {
  fieldName: FieldName;
}
export interface TargetArgument {
  argument: ArgumentMappingTarget;
}
/**
 * An argument target for a relationship mapping.
 */
export interface ArgumentMappingTarget {
  argumentName: ArgumentName;
}
export interface TargetModelField {
  modelField: RelationshipSourceFieldAccess[];
}
/**
 * The definition of how a relationship appears in the GraphQL API
 */
export interface RelationshipGraphQlDefinition {
  /**
   * The field name to use for the field that represents an aggregate over the relationship
   */
  aggregateFieldName?: FieldName | null;
}
/**
 * Definition of permissions for an OpenDD type.
 */
export interface TypePermissionsV1 {
  /**
   * The name of the type for which permissions are being defined. Must be an object type.
   */
  typeName: CustomTypeName;
  /**
   * A list of type permissions, one for each role.
   */
  permissions: TypePermission[];
}
/**
 * Defines permissions for a particular role for a type.
 */
export interface TypePermission {
  /**
   * The role for which permissions are being defined.
   */
  role: Role;
  /**
   * Permissions for this role when this type is used in an output context. If null, this type is inaccessible for this role in an output context.
   */
  output?: TypeOutputPermission | null;
  /**
   * Permissions for this role when this type is used in an input context. If null, this type is accessible for this role in an input context.
   */
  input?: TypeInputPermission | null;
}
/**
 * Permissions for a type for a particular role when used in an output context.
 */
export interface TypeOutputPermission {
  /**
   * Fields of the type that are accessible for a role
   */
  allowedFields: FieldName[];
}
/**
 * Permissions for a type for a particular role when used in an input context.
 */
export interface TypeInputPermission {
  /**
   * Preset values for fields of the type
   */
  fieldPresets?: FieldPreset[];
}
/**
 * Preset value for a field
 */
export interface FieldPreset {
  /**
   * Field name for preset
   */
  field: FieldName;
  /**
   * Value for preset
   */
  value: ValueExpression;
}
/**
 * Definition of permissions for an OpenDD model.
 */
export interface ModelPermissionsV1 {
  /**
   * The name of the model for which permissions are being defined.
   */
  modelName: ModelName;
  /**
   * A list of model permissions, one for each role.
   */
  permissions: ModelPermission[];
}
/**
 * Defines the permissions for an OpenDD model.
 */
export interface ModelPermission {
  /**
   * The role for which permissions are being defined.
   */
  role: Role;
  /**
   * The permissions for selecting from this model for this role. If this is null, the role is not allowed to query the model.
   */
  select?: SelectPermission | null;
}
/**
 * Defines the permissions for selecting a model for a role.
 */
export interface SelectPermission {
  /**
   * Filter expression when selecting rows for this model. Null filter implies all rows are selectable.
   */
  filter: NullableModelPredicate;
  /**
   * Preset values for arguments for this role
   */
  argumentPresets?: ArgumentPreset[];
}
/**
 * Field comparison predicate filters objects based on a field value.
 */
export interface FieldComparisonPredicate {
  /**
   * The field name of the object type of the model to compare.
   */
  field: FieldName;
  /**
   * The name of the operator to use for comparison.
   */
  operator: OperatorName;
  /**
   * The value expression to compare against.
   */
  value: ValueExpression;
}
/**
 * Predicate to check if the given field is null.
 */
export interface FieldIsNullPredicate {
  /**
   * The name of the field that should be checked for a null value.
   */
  field: FieldName;
}
/**
 * Relationship predicate filters objects of a source model based on a predicate on the related model.
 */
export interface RelationshipPredicate {
  /**
   * The name of the relationship of the object type of the model to follow.
   */
  name: RelationshipName;
  /**
   * The predicate to apply on the related objects. If this is null, then the predicate evaluates to true as long as there is at least one related object present.
   */
  predicate?: ModelPredicate | null;
}
/**
 * Evaluates to true if all sub-predicates evaluate to true.
 */
export interface And {
  and: ModelPredicate[];
}
/**
 * Evaluates to true if any of the sub-predicates evaluate to true.
 */
export interface Or {
  or: ModelPredicate[];
}
/**
 * Evaluates to true if the sub-predicate evaluates to false.
 */
export interface Not {
  not: ModelPredicate;
}
/**
 * Preset value for an argument
 */
export interface ArgumentPreset {
  /**
   * Argument name for preset
   */
  argument: ArgumentName;
  /**
   * Value for preset
   */
  value: ValueExpressionOrPredicate;
}
export interface Literal1 {
  literal: unknown;
}
export interface SessionVariable1 {
  sessionVariable: OpenDdSessionVariable;
}
export interface BooleanExpression {
  booleanExpression: ModelPredicate;
}
/**
 * Definition of permissions for an OpenDD command.
 */
export interface CommandPermissionsV1 {
  /**
   * The name of the command for which permissions are being defined.
   */
  commandName: CommandName;
  /**
   * A list of command permissions, one for each role.
   */
  permissions: CommandPermission[];
}
/**
 * Defines the permissions for a role for a command.
 */
export interface CommandPermission {
  /**
   * The role for which permissions are being defined.
   */
  role: Role;
  /**
   * Whether the command is executable by the role.
   */
  allowExecution: boolean;
  /**
   * Preset values for arguments for this role
   */
  argumentPresets?: ArgumentPreset[];
}
/**
 * Definition of a lifecycle plugin hook for the pre-parse stage.
 */
export interface LifecyclePluginHookPreParse {
  pre: 'parse';
  /**
   * The name of the lifecycle plugin hook.
   */
  name: string;
  /**
   * The URL to access the lifecycle plugin hook.
   */
  url: string;
  /**
   * Configuration for the lifecycle plugin hook.
   */
  config: LifecyclePluginHookConfig;
}
/**
 * Configuration for a lifecycle plugin hook.
 */
export interface LifecyclePluginHookConfig {
  /**
   * Configuration for the request to the lifecycle plugin hook.
   */
  request: LifecyclePluginHookConfigRequest;
}
/**
 * Configuration for a lifecycle plugin hook request.
 */
export interface LifecyclePluginHookConfigRequest {
  /**
   * Configuration for the headers.
   */
  headers?: LifecyclePluginHookHeadersConfig | null;
  /**
   * Configuration for the session (includes roles and session variables).
   */
  session?: LeafConfig | null;
  /**
   * Configuration for the raw request.
   */
  rawRequest: RawRequestConfig;
}
/**
 * Configuration for a lifecycle plugin hook headers.
 */
export interface LifecyclePluginHookHeadersConfig {
  /**
   * Additional headers to be sent with the request.
   */
  additional?: HttpHeaders | null;
  /**
   * Headers to be forwarded from the incoming request.
   */
  forward?: string[];
}
/**
 * Leaf Configuration.
 */
export interface LeafConfig {}
/**
 * Configuration for the raw request.
 */
export interface RawRequestConfig {
  /**
   * Configuration for the query.
   */
  query?: LeafConfig | null;
  /**
   * Configuration for the variables.
   */
  variables?: LeafConfig | null;
}
export interface V2_Metadata {
  version: 'v2';
  subgraphs?: V2_Subgraph[];
}
export interface V2_Subgraph {
  name: string;
  objects: V2_SubgraphObject[];
}
/**
 * The compatibility configuration of the Hasura metadata.
 */
export interface V2_CompatibilityConfig {
  kind: 'CompatibilityConfig';
  /**
   * Any backwards incompatible changes made to Hasura DDN after this date won't impact the metadata.
   */
  date: CompatibilityDate;
}
/**
 * Definition of the authentication configuration v1, used by the API server.
 */
export interface AuthConfigV12 {
  kind: 'AuthConfig';
  version: 'v1';
  definition: AuthConfigV11;
}
/**
 * Definition of the authentication configuration v2, used by the API server.
 */
export interface AuthConfigV22 {
  kind: 'AuthConfig';
  version: 'v2';
  definition: AuthConfigV21;
}
